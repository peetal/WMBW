---
title: "WMBW_Schaefer400"
output: html_document
---

```{r setup, include=FALSE, cache = TRUE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r warning=FALSE,message=FALSE}
library(rio)
library(tidyverse)
library(sjmisc)
library(DescTools)
library(tidymodels)
library(janitor)
library(magrittr)
library(doParallel)
library(kableExtra)
#library(Rmisc)
library(afex)
library(cocor)
```

### Check and remove potential outliers (behavioral and neural)
```{r outlier_check}
rm(list = ls())

# load in the COPE11 data with Schaefer400 parcellation scheme applied:
schaefer400_cope11 <- import(here::here('./data/wm_schaf_cope11_pe_2mm_pe_400.csv'))
# load in behavioral results (2-back, list-sorting, Pmat, picVocalb, reading_recog)
behavioral <- import(here::here('./data/HCP_behavioral_data.csv')) %>%
  select(Subject, WM_Task_2bk_Acc, ListSort_AgeAdj, PMAT24_A_CR, PicVocab_AgeAdj, ReadEng_AgeAdj)
# merge and remove na
working_df <- inner_join(schaefer400_cope11, behavioral, by = 'Subject') %>% 
  na.omit()

# subjects who had more than 20 parcels showing extreme values. 
lower_threshold <- 
  working_df[,2:ncol(schaefer400_cope11)] %>%
  map_dbl(~ quantile(., 0.25) - 1.5*IQR(.)) %>% unname()
upper_threshold <-  
  working_df[,2:ncol(schaefer400_cope11)] %>%
  map_dbl(~ quantile(., 0.75) + 1.5*IQR(.)) %>% unname()

working_df_copy1 <-data.frame(working_df)
for (col in 2:ncol(schaefer400_cope11)){
  working_df_copy1[,col] <- ifelse((working_df_copy1[,col] < lower_threshold[col-1]) | (working_df_copy1[,col] > upper_threshold[col-1]), 1, 0)
}

outlier_index_neural <- 
  working_df_copy1[,1:ncol(schaefer400_cope11)] %>% 
  pivot_longer(., LH_Cont_Cing_1: RH_Vis_9, names_to = "parcel_name",  values_to = "value") %>%
  filter(value == 1) %>%
  count(Subject) %>% 
  filter(n > 40)

# subjects who had extreme value in any of the behavioral measure.
lower_threshold <- 
  working_df[,(ncol(schaefer400_cope11)+1):ncol(working_df)] %>%
  map_dbl(~ quantile(., 0.25) - 1.5*IQR(.)) %>% unname()
upper_threshold <-  
  working_df[,(ncol(schaefer400_cope11)+1):ncol(working_df)] %>%
  map_dbl(~ quantile(., 0.75) + 1.5*IQR(.)) %>% unname()

working_df_copy2 <-data.frame(working_df)
for (col in (ncol(schaefer400_cope11)+1):ncol(working_df)){
  working_df_copy2[,col] <- ifelse((working_df_copy2[,col] < lower_threshold[col-401]) | (working_df_copy2[,col] > upper_threshold[col-401]), 1, 0)
}

outlier_index_behavioral <- 
  working_df_copy2 %>% 
  select(Subject, WM_Task_2bk_Acc, ListSort_AgeAdj, PMAT24_A_CR, PicVocab_AgeAdj, ReadEng_AgeAdj) %>%
  pivot_longer(., WM_Task_2bk_Acc: ReadEng_AgeAdj, names_to = "parcel_name",  values_to = "value") %>%
  filter(value == 1) %>%
  count(Subject)

outlier_index_behavioral

# index the good subjects 
#good_sub <- working_df$Subject[!(working_df$Subject %in% outlier_index_neural$Subject)]
# rewrite the neural data: 
#schaefer400_cope11 %>% 
#  filter(Subject %in% good_sub) %>%
#  write.csv(., file = "./data/schaefer400_cope11_rm_outlier.csv", row.names = FALSE)
```

### Parcels have larger effect sizes
```{r parcel_es, warning = F}
rm(list = ls())

# load in the COPE11 data with Schaefer400 parcellation scheme applied:
schaefer400_cope11 <- import(here::here('./data/schaefer400_cope11_rm_outlier.csv')) %>%
  select(-Subject) # dont care about subject id here

# set up parameters: 
network_suffix <- c('Cont','Default','DorsAttn','Limbic','SalVentAttn','SomMot','Vis')
cohenD <- c() # Each parcel's load effect effect size
networks<- c() # Each parcel's network 
num <- c() # count the number of parcels in each network 
for (i in network_suffix) { # i <- 'Cont'
  num <- append(num, ncol(schaefer400_cope11[,grep(i,colnames(schaefer400_cope11))])) # number of parcels in each network
  cohenD <- append(cohenD, schaefer400_cope11[,grep(i,colnames(schaefer400_cope11))] %>%
                     map(~ (mean(.)/sd(.)))) # effect size for each parcel mean of the effect over sd of the data (Poldrack et al., 2017) 
  networks <- append(networks, rep(i,ncol(schaefer400_cope11[,grep(i,colnames(schaefer400_cope11))]))) # network names 
}

# create a data frame that has network and effect_size. 
info_table <- data.frame(array(data=NA, dim = c(400,2)))
colnames(info_table) <- c("network_name","effect_size")
info_table$effect_size <- as.numeric(cohenD)
info_table$network_name <- networks

# change the name for network for plotting purpose
for (i in 1: length(network_suffix)) {
  info_table$network_name <- gsub(pattern = network_suffix[i], replacement = paste0(network_suffix[i],"(",num[i],")"), x = info_table$network_name)
}

# get ready for plotting
colors = c("steelblue","moccasin","mediumorchid4","indianred3","purple3","springgreen4","tan2") # match the color of the brain network
info_table %>%
  mutate(network_name = as.factor(info_table$network_name),
         network_name = reorder(info_table$network_name, info_table$effect_size, FUN = mean)) %>%
  ggplot(aes(network_name, effect_size)) + 
  geom_violin(fill = "gray") + 
  geom_boxplot(width = 0.2, fill = "white") +
  #theme(legend.position = "right") +
  scale_y_continuous(breaks = c(-1,-0.5,0,0.5,1,1.5)) + 
  scale_x_discrete(limits=c("SomMot(77)","Limbic(26)",
                            "Vis(61)","Default(91)","SalVentAttn(47)","DorsAttn(46)",
                            "Cont(52)")) +
  coord_flip() +
  geom_hline(yintercept = 0.8, linetype = "dashed", color = "red") +
  annotate("text", x = 1, y = 1.1, label = "d = 0.8", color = "red") +
  theme_minimal() +
  theme(axis.title.x = element_text(size = 13, face ="bold"),
        axis.text.x = element_text(size = 13, face = "bold", margin = margin(t = 0, r = 0, b = 10, l = 0)),
        axis.title.y = element_text(size = 13, face = "bold", margin = margin(t = 0, r = 10, b = 0, l = 0)),
        axis.text.y = element_text(size = 13, color = colors,face = "bold"), 
        plot.margin = margin(1,1,0,1,"cm")) +
  ylab("Effect Size") +
  xlab("Schaefer 7 Networks")

# Stats
info_table %>%
  mutate(network_name = as.factor(network_name)) %>%
  group_by(network_name) %>%
  summarize(mean_effect_size = mean(effect_size))

```

### Identification of WM-involved networks.
```{r distinct_network}
rm(list = ls())

# read in neural and behavioral data
schaefer400_cope11 <- import(here::here('./data/schaefer400_cope11_rm_outlier.csv'))
behavioral <- import(here::here('./data/HCP_behavioral_data.csv')) %>%
  select(Subject, WM_Task_2bk_Acc)
# join 
working_df <- inner_join(schaefer400_cope11, behavioral, by = 'Subject') %>% 
  na.omit()

# ------------------------------------------------------------------------------
# to identify brain network that is sensitive to within-subject variations
# ------------------------------------------------------------------------------
# do a one sample t test for each parcel to identify within network
within_ttest <- 
  working_df %>%
  select(-c(Subject,WM_Task_2bk_Acc)) %>%
  map(~t.test(., mu = 0, alternative = "two.sided"))

# load activated parcel in the within network
load_activated_parcel_ttest <- 
  within_ttest[within_ttest %>% map(~.$statistic) > 0]
load_activated_parcel <- 
  load_activated_parcel_ttest[load_activated_parcel_ttest %>% map(~.$p.value) < 0.05/length(within_ttest)] %>%
  names()

# load deactivated parcel in the within network
load_deactivated_parcel_ttest <- 
  within_ttest[within_ttest %>% map(~ .$statistic) < 0]
load_deactivated_parcel <- 
  load_deactivated_parcel_ttest[load_deactivated_parcel_ttest %>% map(~.$p.value) < 0.05/length(within_ttest)] %>%
  names()

# load insensitive parcel 
load_insensitive_parcel <- colnames(schaefer400_cope11)[-1][! colnames(schaefer400_cope11)[-1] %in% c(load_activated_parcel,load_deactivated_parcel)]

# ------------------------------------------------------------------------------
# to identify brain network that is sensitive to between-subject variations
# ------------------------------------------------------------------------------

# parcels activation correlates with behavioral performance (between-network)
between_cortest_list <- 
  working_df %>%
  select(-c(Subject, WM_Task_2bk_Acc)) %>%
  map(~cor.test(., working_df$WM_Task_2bk_Acc))
  
# parcels that are positively correlated with behavior
beh_pos_cor_parcel_ttest <-
  between_cortest_list[between_cortest_list %>% map(~ magrittr::extract2(., 4)) > 0]
beh_pos_cor_parcel_name <-
  beh_pos_cor_parcel_ttest[beh_pos_cor_parcel_ttest %>% map(~ magrittr::extract2(., 3)) < 0.05/length(between_cortest_list)] %>%
  names()

# parcels that are negatively correlated with behavior
beh_neg_cor_parcel_ttest <-
  between_cortest_list[between_cortest_list %>% map(~ magrittr::extract2(., 4)) < 0]
beh_neg_cor_parcel_name <-
  beh_neg_cor_parcel_ttest[beh_neg_cor_parcel_ttest %>% map(~ magrittr::extract2(., 3)) < 0.05/length(between_cortest_list)] %>%
  names()

# --------------------------------------------------------
# Check the consistency of the directions of the effects. 
# --------------------------------------------------------
# out of 177 parcels exhibiting between-subjects WM effects, how many of them also 
# sensitive to within-subject difference? 
# n = 175
sum(c(beh_pos_cor_parcel_name,beh_neg_cor_parcel_name)  %in% c(load_activated_parcel, load_deactivated_parcel))
# out of 120 parcels showing positive behavioral correlation, how many are load-activated?
# n = 113
sum(beh_pos_cor_parcel_name %in% load_activated_parcel)
# out of 57 parcels showing negative behavioral correaltion, how many are load-deactivated?
# n = 57
sum(beh_neg_cor_parcel_name %in% load_deactivated_parcel)

```

### Parcels contribute to between and within-subject variations equivalently. 
```{r compare_es,warning=FALSE,message=FALSE}

# get cohenD and correlation coefficient ranking for every parcel: 
es_info <- data.frame(array(data=NA, dim = c(400,3)))
colnames(es_info) <- c('parcel_names','cohenD','coref') # colun names 
es_info$parcel_names <- colnames(working_df)[2:401] # parcel names 
es_info$cohenD <- working_df[,2:401] %>% map_dbl(~ (mean(.)/sd(.))) # compute cohen's D 
es_info$coref <- 
  working_df[,2:401] %>% 
  map_dbl(~ (cor.test(.,working_df$WM_Task_2bk_Acc)$estimate)) # compute correaltion with behavior. 

# rank the absolute values of the two effect sizes. 
es_info <- es_info %>%
  mutate(rank_cohenD = 401 - rank(abs(es_info$cohenD)),
         rank_coref = 401 - rank(abs(es_info$coref)),
         Parcel_type = ifelse(es_info$parcel_names %in% load_activated_parcel, 'Load-Activated', ifelse(es_info$parcel_names %in% load_deactivated_parcel, 'Load-Deactivated','Load-Insensitive')))

# get all parcels names in either load-activated network or between network, plot the two rank for these parcels
colors = c("red","blue","grey")
es_info %>%
  ggplot(aes(x = rank_cohenD, y = rank_coref, color = Parcel_type)) + 
  facet_grid(cols = vars(Parcel_type), scales = 'free') + 
  geom_point(alpha = 0.3) + 
  geom_smooth(method = 'lm', se = F) + 
  scale_color_manual(values = colors) + 
  theme_minimal() +
  theme(axis.title.x = element_text(size = 13, face ="bold"),
        axis.text.x = element_text(size = 10),
        axis.title.y = element_text(size = 13, face = "bold"),
        axis.text.y = element_text(size = 10, face = "bold"), 
        strip.text.x = element_text(size = 13, face = "bold"),
        plot.margin = margin(1,1,0,1,"cm"),
        legend.title = element_blank(),
        legend.position = 'None') +
  xlab("Within-subject effect rank \n(rank of |Cohen's d|)") +
  ylab("Between-subject effect rank \n(rank of |r|)")  

# --------------------------------------------------------------------------------------
# compute Spearman correlation coefficient of the rank orders of the two effect sizes. 
# for 3 functional groups separately. 
# --------------------------------------------------------------------------------------
within_between_es <- 
  es_info %>%
  group_by(Parcel_type) %>%
  nest() %>%
  mutate(cortest = map(data, ~ cor.test(.$rank_cohenD, .$rank_coref, data = ., method = "spearman")),
         estimate = map_dbl(cortest, ~ .$estimate),
         p_value = map_dbl(cortest, ~ .$p.value)) %>% 
  select(Parcel_type, estimate, p_value)
within_between_es

# -----------------------------------------
# z test for the correlation coefficients. 
# -----------------------------------------
parcel_count <- 
  es_info %>%
    group_by(Parcel_type) %>%
    summarize(count = n())
r_activated <- within_between_es$estimate[2]
n_activated <- parcel_count$count[1]
r_deactivated <- within_between_es$estimate[3]
n_deactivated <- parcel_count$count[2]

# is the coupling of the two effect sizes stronger for load-activated parcels? 
z_diff <- atanh(r_activated) - atanh(r_deactivated)
z_se <- ((1/(n_activated-3))+(1/(n_deactivated-3)))^0.5
2*(1-pnorm(z_diff/z_se))

#2. table
#3. cifti writing. 

```

### Load-effect sizes indicates parcel's predictive power
```{r nested_permutation}
rm(list = ls())
# plotting for predictive power per parcel bins: 
plot_pred_acc_bin <- function(df_name, measure){
  # load dataframe
  df_inscanner <- import(here::here(paste0("data/schaefer_permutation/",df_name)))
  # select real_data
  real_data <- 
    df_inscanner[1,] %>% 
    pivot_longer(., -load_insensitive, names_to = c("parcel_type","effect_size"), 
                 values_to = "pred_acc", names_pattern = "(.*)_(.*_.*)" ) %>%
    mutate(parcel_type = ifelse(parcel_type == "act", "Activated", "Deactivated"))
  # plotting 
  plot <-  
    real_data %>% 
    ggplot(aes(x = effect_size, y = pred_acc, color = parcel_type)) +
    geom_point() + 
    geom_line(aes(group = parcel_type, color = parcel_type)) + 
    geom_hline(yintercept = df_inscanner$load_insensitive[1], color = "gray", linetype = "dashed") + 
    ylim(0, df_inscanner$act_13_15[1] + 0.1) + 
    xlab("Parcel Bins based on ES") + 
    ylab("Predictive Acc") + 
    ggtitle(paste0("Predictive accuracy for ", measure)) + 
    scale_x_discrete(labels=c("01_03" = "(0.1,0.3)", "03_05" = "(0.3,0.5)", "05_07" = "(0.5,0.7)", 
                              "07_09" = "(0.7,0.9)", "09_11" = "(0.9,1.1)", "11_13" = "(1.1,1.3)",
                              "13_15" = "(1.3,1.5)")) + 
    theme_minimal() +
    theme(axis.title.x = element_text(size = 13, face = 'bold'),
          axis.text.x = element_text(size = 13, face = 'bold'),
          axis.title.y = element_text(size = 13, face = "bold"),
          axis.text.y = element_text(size = 13, face = "bold"), 
          plot.title = element_text(size = 15, face = "bold"),
          plot.margin = margin(1,1,0,1,"cm"),
          legend.position = c(0.2, 0.8)) 
  return(plot)
}

# linear trend statistical test: 
linear_trend_stats <- function(df_name){ #df_name = "schaefer_nested_permutation_test_12bin_WM_Task_2bk_Acc.csv"
  df <- import(here::here(paste0("data/schaefer_permutation/",df_name)))
  # select real_data
  real_data <- 
    df[1,] %>% 
    pivot_longer(., -load_insensitive, names_to = c("parcel_type","effect_size"), 
                 values_to = "pred_acc", names_pattern = "(.*)_(.*_.*)" ) %>%
    mutate(parcel_type = ifelse(parcel_type == "act", "Activated", "Deactivated"))
  # linear trend for activated
  act_real_lt <- real_data %>%
    filter(parcel_type == "Activated") %>%
    mutate(effect_size_rank = c(1,2,3,4,5,6,7)) %>%
    lm(pred_acc ~ effect_size_rank, .) %>% 
    summary()
  # linear trend for deactivated
  deact_real_lt <- real_data %>% 
    filter(parcel_type == "Deactivated") %>%
    mutate(effect_size_rank = c(1,2,3,4)) %>% 
    lm(pred_acc ~ effect_size_rank, .) %>% 
    summary()
  # null linear trend coefficient for activated bins
  null_coef_act <- c()
  for (row in 2:1001){
    mat <- matrix(c(as.numeric(df[row,1:7]), c(1,2,3,4,5,6,7)), ncol = 2)
    null_lt <- lm(mat[,1]~ mat[,2]) %>% summary()
    null_coef_act <- append(null_coef_act, null_lt$coefficients[2,1])
  }
  # null linear trend coefficient for deactivated bins
  null_coef_deact <- c()
  for (row in 2:1001){
    mat <- matrix(c(as.numeric(df[row,8:11]), c(1,2,3,4)), ncol = 2)
    null_lt <- lm(mat[,1]~ mat[,2]) %>% summary()
    null_coef_deact <- append(null_coef_deact, null_lt$coefficients[2,1])
  }
  # compute p-values for the observed linear trend coefficients. 
  act_real_lt_p <- (1- pnorm((act_real_lt$coefficients[2,1] - mean(null_coef_act))/sd(null_coef_act)))*2
  deact_real_lt_p <- (1- pnorm((deact_real_lt$coefficients[2,1] - mean(null_coef_deact))/sd(null_coef_deact)))*2
  
  print(paste0("Act linear trend coefficient is ", act_real_lt$coefficients[2,1], "and its P values is ", act_real_lt_p))
  print(paste0("Deact linear trend coefficient is ", deact_real_lt$coefficients[2,1], "and its P values is ", deact_real_lt_p))
}

# compare load-activated and load-deactivated parcels given the same effect size. 
compare_pred_acc_bins <- function(df_name){ # df_name = "schaefer_nested_permutation_test_12bin_WM_Task_2bk_Acc.csv"
  
  # load data 
  df <- import(here::here(paste0("data/schaefer_permutation/",df_name)))
  # extract bins to be compared with 
  real <- data.frame("activated" = as.numeric(df[1,1:4]),
                     "deactivated" = as.numeric(df[1,8:11]),
                     "insensitive" = rep(as.numeric(df[1,12]), 4)) %>%
    mutate(act_minus_deactivated = activated - deactivated,
           deactivated_minus_insensitive = deactivated - insensitive,
           activated_minus_insensitive = activated - insensitive) %>%
    select(act_minus_deactivated, deactivated_minus_insensitive, activated_minus_insensitive)
  
  # build null distribution
  null_01_03 <- c()
  null_03_05 <- c()
  null_05_07 <- c()
  null_07_09 <- c()
  for (row in 2:1001){ # row = 2
      mat <- data.frame("activated" = as.numeric(df[row,1:4]),
                         "deactivated" = as.numeric(df[row,8:11]),
                         "insensitive" = rep(as.numeric(df[row,12]), 4)) %>%
        mutate(act_minus_deactivated = activated - deactivated,
               deactivated_minus_insensitive = deactivated - insensitive,
               activated_minus_insensitive = activated - insensitive) %>%
        select(act_minus_deactivated, deactivated_minus_insensitive, activated_minus_insensitive)
      # build null distribution for the differences of load-activated and deactivated bins
      null_01_03 <- append(null_01_03, mat$act_minus_deactivated[1])
      null_03_05 <- append(null_03_05, mat$act_minus_deactivated[2])
      null_05_07 <- append(null_05_07, mat$act_minus_deactivated[3])
      null_07_09 <- append(null_07_09, mat$act_minus_deactivated[4])
  } 
  
  
  # compute p values: 
  p_01_03 <- (1- pnorm(abs(real$act_minus_deactivated[1] - mean(null_01_03))/sd(null_01_03)))*2
  p_03_05 <- (1- pnorm(abs(real$act_minus_deactivated[2] - mean(null_03_05))/sd(null_03_05)))*2
  p_05_07 <- (1- pnorm(abs(real$act_minus_deactivated[3] - mean(null_05_07))/sd(null_05_07)))*2
  p_07_09 <- (1- pnorm(abs(real$act_minus_deactivated[4] - mean(null_07_09))/sd(null_07_09)))*2

  print(paste0("Difference in bin 01_03 is ", real$act_minus_deactivated[1], "P value is ",  p_01_03))
  print(paste0("Difference in bin 03_05 is ", real$act_minus_deactivated[2], "P value is ",  p_03_05))
  print(paste0("Difference in bin 05_07 is ", real$act_minus_deactivated[3], "P value is ",  p_05_07))
  print(paste0("Difference in bin 07_09 is ", real$act_minus_deactivated[4], "P value is ",  p_07_09))
  
}


# WM_Task_2bk_Acc
plot_pred_acc_bin("schaefer_nested_permutation_test_12bin_WM_Task_2bk_Acc.csv", "2-back task")
linear_trend_stats("schaefer_nested_permutation_test_12bin_WM_Task_2bk_Acc.csv")
compare_pred_acc_bins("schaefer_nested_permutation_test_12bin_WM_Task_2bk_Acc.csv")

# PicVocab_AgeAdj
plot_pred_acc_bin("schaefer_nested_permutation_test_12bin_PicVocab_AgeAdj.csv", "Pic-vocab task")
linear_trend_stats("schaefer_nested_permutation_test_12bin_PicVocab_AgeAdj.csv")
compare_pred_acc_bins("schaefer_nested_permutation_test_12bin_PicVocab_AgeAdj.csv")

# PMAT24_A_CR
plot_pred_acc_bin("schaefer_nested_permutation_test_12bin_PMAT24_A_CR.csv", "PMAT task")
linear_trend_stats("schaefer_nested_permutation_test_12bin_PMAT24_A_CR.csv")
compare_pred_acc_bins("schaefer_nested_permutation_test_12bin_PMAT24_A_CR.csv")

# ReadEng_AgeAdj
plot_pred_acc_bin("schaefer_nested_permutation_test_12bin_ReadEng_AgeAdj.csv", "Reading-cog task")
linear_trend_stats("schaefer_nested_permutation_test_12bin_ReadEng_AgeAdj.csv")
compare_pred_acc_bins("schaefer_nested_permutation_test_12bin_ReadEng_AgeAdj.csv")

# ListSort_AgeAdj
plot_pred_acc_bin("schaefer_nested_permutation_test_12bin_ListSort_AgeAdj.csv", "List-sort task")
linear_trend_stats("schaefer_nested_permutation_test_12bin_ListSort_AgeAdj.csv")
compare_pred_acc_bins("schaefer_nested_permutation_test_12bin_ListSort_AgeAdj.csv")
```

### Use load-effect to guide feature selection
```{r}
rm(list = ls())

plot_feature_selection <- function(df_dir){
  # read in data
  df <- import(here::here(paste0("data/schaefer_permutation/", df_dir)))
  # extract null 
  null <- df %>%
    select(lower, mean, upper, idx)
  # plot
  plot <- 
    df %>%
      ggplot(aes(x = idx, y = observed)) + 
      geom_point(aes(color = parcel_type), size = 2) + 
      geom_line(color = "black", size = 1) + 
      geom_point(data = null, aes(x = idx, y = mean), alpha = 0.1, color = "gray1") + 
      geom_line(data = null, aes(x = idx, y = mean), color = "gray1", alpha = 0.1) +
      geom_ribbon(data = null, aes(x = idx, ymin = lower, ymax = upper), fill = "gray1", 
                  linetype = 2, alpha = 0.1, inherit.aes = F) + 
      theme_minimal() + 
      ylab("Predictive Acc") + 
      xlab("Top n parcels \n (Based on CohenD)") + 
      scale_x_continuous(breaks=seq(0, 60, 10))+ 
      theme(axis.title.x = element_text(size = 13, face = 'bold'),
            axis.text.x = element_text(size = 10, face = 'bold'),
            axis.title.y = element_text(size = 13, face = "bold"),
            axis.text.y = element_text(size = 13, face = "bold"), 
            strip.text.x = element_text(size = 13, face = "bold"),
            plot.margin = margin(1,1,0,1,"cm"),
            legend.position = "none",
            legend.title = element_blank()) 
  
  return(plot)
}

# WM_Task_2bk_Acc
plot_feature_selection("schaefer_feature_selection_permutation_WM_Task_2bk_Acc.csv")
# PicVocab_AgeAdj
plot_feature_selection("schaefer_feature_selection_permutation_PicVocab_AgeAdj.csv")
# PMAT24_A_CR
plot_feature_selection("schaefer_feature_selection_permutation_PMAT24_A_CR.csv")
# ReadEng_AgeAdj
plot_feature_selection("schaefer_feature_selection_permutation_ReadEng_AgeAdj.csv")
# ListSort_AgeAdj
plot_feature_selection("schaefer_feature_selection_permutation_ListSort_AgeAdj.csv")

```

